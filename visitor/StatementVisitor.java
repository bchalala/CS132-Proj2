//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import utility.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class StatementVisitor extends GJVoidDepthFirst<Pair<String, Vector<Pair<String, ExpType>>>> {
  
   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> ( VarDeclaration() )*
    * f15 -> ( Statement() )*
    * f16 -> "}"
    * f17 -> "}"
    */
   public void visit(MainClass n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      LocalVarVisitor lvvis = new LocalVarVisitor();
      Vector<Pair<String, ExpType>> locals = n.f14.accept(lvvis);
      if (!ClassTypes.areNamesUnique(locals)) {
        System.out.println("Locals aren't unique");
        System.out.println("Type Error");
        System.exit(1);
      } 

      Pair<String, Vector<Pair<String, ExpType>>> env = 
        new Pair<String, Vector<Pair<String, ExpType>>>(ClassTypes.mainClass, locals);

      n.f15.accept(this, env);
   }


   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public void visit(ClassDeclaration n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      Pair<String, Vector<Pair<String, ExpType>>> env = 
        new Pair<String, Vector<Pair<String, ExpType>>>(n.f1.f0.toString(), null);

      n.f4.accept(this, env);
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public void visit(ClassExtendsDeclaration n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      Pair<String, Vector<Pair<String, ExpType>>> env = 
        new Pair<String, Vector<Pair<String, ExpType>>>(n.f1.f0.toString(), null);

      n.f6.accept(this, env);
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public void visit(MethodDeclaration n, Pair<String, Vector<Pair<String, ExpType>>> argu) {

      // Get the method information, its type, then remove it from the method info vector
      Vector<Pair<String, ExpType>> methodInfo = ClassTypes.getMethodInfo(argu.x, n.f2.f0.toString());
      ExpType methodtype = methodInfo.elementAt(0).y;

      // Get the local variables for the function, build the environment, then check the environment.
      LocalVarVisitor lvvis = new LocalVarVisitor();
      Vector<Pair<String, ExpType>> locals = n.f7.accept(lvvis);
      int s = locals.size();
      locals.addAll(methodInfo);
      if (s < locals.size())
        locals.remove(s);

      if (!ClassTypes.areNamesUnique(locals)) {
        System.out.println("Locals not unique");
        System.out.println("Type Error");
        System.exit(1);
      } 

       Pair<String, Vector<Pair<String, ExpType>>> env = 
        new Pair<String, Vector<Pair<String, ExpType>>>(argu.x, locals);

      // Check statements with environment enabled
      n.f8.accept(this, env);

      // Ensure that function returns an expression of the correct type
      ExpressionVisitor ev = new ExpressionVisitor();
      ExpType t = n.f10.accept(ev, env);
      if (!t.isEqual(methodtype)) {
        System.out.println("Incorrect return type for function");
        System.out.println("Type Error");
        System.exit(1);
      }
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public void visit(Statement n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      n.f0.accept(this, argu);
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public void visit(Block n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      n.f1.accept(this, argu);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public void visit(AssignmentStatement n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpressionVisitor ev = new ExpressionVisitor();
      String id = n.f0.f0.toString();
      ExpType t1 = ClassTypes.getType(argu.x, id, argu.y);
      ExpType t2 = n.f2.accept(ev, argu);

      if (!t1.isEqual(t2)) {
        System.out.println("Bad Assignment");
        System.out.println("Type Error");
        System.exit(1);
      }

   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public void visit(ArrayAssignmentStatement n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpressionVisitor ev = new ExpressionVisitor();
      ExpType t = n.f2.accept(ev, argu);
      if (t.getType() != ExpType.Type.INT) {
        System.out.println("Bad array access");
        System.out.println("Type Error");
        System.exit(1);
      }
      t = n.f5.accept(ev, argu);
      if (t.getType() != ExpType.Type.INT) {
        System.out.println("Bad array access");
        System.out.println("Type Error");
        System.exit(1);
      }

      String id = n.f0.f0.toString();
      t = ClassTypes.getType(argu.x, id, argu.y);
      if (t.getType() != ExpType.Type.INTARR) {
        System.out.println("Bad array access");
        System.out.println("Type Error");
        System.exit(1);
      }
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public void visit(IfStatement n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpressionVisitor ev = new ExpressionVisitor();
      ExpType t = n.f2.accept(ev, argu);
      if (t.getType() != ExpType.Type.BOOLEAN) {
        System.out.println("Problem with if else");
        System.out.println("Type Error");
        System.exit(1);
      }

      n.f4.accept(this, argu);
      n.f6.accept(this, argu);
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public void visit(WhileStatement n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpressionVisitor ev = new ExpressionVisitor();
      ExpType t = n.f2.accept(ev, argu);
      if (t.getType() != ExpType.Type.BOOLEAN) {
        System.out.println("Problem with while loop");
        System.out.println("Type Error");
        System.exit(1);
      }

      n.f4.accept(this, argu);
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public void visit(PrintStatement n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpressionVisitor ev = new ExpressionVisitor();
      ExpType t = n.f2.accept(ev, argu);
      if (t.getType() != ExpType.Type.INT) {
        System.out.println("Problem with print statement");
        System.out.println("Type Error");
        System.exit(1);
      }
   }

}
