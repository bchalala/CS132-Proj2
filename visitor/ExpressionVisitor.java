//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import utility.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class ExpressionVisitor extends GJDepthFirst<ExpType, Pair<String, Vector<Pair<String, ExpType>>>> {

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public ExpType visit(Expression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(AndExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.BOOLEAN)
        return t1;
      
      // If the types aren't the same do this.
      System.out.println("and exp");
      System.out.println("Type Error");
      System.exit(1);

      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(CompareExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.INT) {
        return new ExpType(ExpType.Type.BOOLEAN);
      }
      
      // If the types aren't the same do this.
      System.out.println("comparison");
      System.out.println("Type Error");
      System.exit(1);
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(PlusExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.INT)
        return t1;
      
      // If the types aren't the same do this.
      System.out.println("addition");
      System.out.println("Type Error");
      System.exit(1);
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(MinusExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.INT)
        return t1;
      
      // If the types aren't the same do this.
      System.out.println("subtraction");
      System.out.println("Type Error");
      System.exit(1);
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(TimesExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.INT)
        return t1;
      
      // If the types aren't the same do this.
      System.out.println("mult");
      System.out.println("Type Error");
      System.exit(1);
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public ExpType visit(ArrayLookup n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.getType() == ExpType.Type.INTARR && t2.getType() == ExpType.Type.INT)
        return t2;
      
      // If the types aren't the same do this.
      System.out.println("arr access");
      System.out.println("Type Error");
      System.exit(1);
      return null;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public ExpType visit(ArrayLength n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = n.f0.accept(this, argu);
      if (t.getType() == ExpType.Type.INTARR) {
        ExpType tnew = new ExpType(ExpType.Type.INT);
        return tnew;
      }
      System.out.println("arr length");
      System.out.println("Type Error");
      System.exit(1);   
      return null;
    }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public ExpType visit(MessageSend n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = n.f0.accept(this, argu);

      // Primary expression must result in a variable of a class.
      if (t.getType() != ExpType.Type.ID) {
        System.out.println("Incorrect identifier for passing messages");
        System.out.println("Type Error");
        System.exit(1);  
        return null;
      }

      // Gets the name of the method
      String method = n.f2.f0.toString();

      // Retrieves method information (this type checks the method name)
      Vector<Pair<String, ExpType>> methodInfo = ClassTypes.getMethodInfo(t.getID(), method);

      // Use separate visitor to retrieve the method argument types.
      ExpMethodVisitor emvis = new ExpMethodVisitor();
      Vector<ExpType> typeVec = n.f4.accept(emvis, argu);

      // typeVec is the types of all the args whereas methodInfo includes the type of the 
      // method at the head of its list.
      if (typeVec.size() + 1 != methodInfo.size()) {
        System.out.println("Incorrect method info (size)");
        System.out.println("Type Error");
        System.exit(1); 
      }

      // Check all types for equality
      for (int i = 1; i < methodInfo.size(); i++) {
        if (!typeVec.elementAt(i - 1).isEqual(methodInfo.elementAt(i).y)) {
            if (ClassTypes.isASubtype(typeVec.elementAt(i - 1).getID(), methodInfo.elementAt(i).y.getID()))
              continue;
            System.out.println("Method: " + method);
            System.out.println("Incorrect method info (element)");
            System.out.println("Type Error");
            System.exit(1); 
        }
      }

      // Return the method type
      return methodInfo.elementAt(0).y;
   }


   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public ExpType visit(PrimaryExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = n.f0.accept(this, argu);
      return t;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public ExpType visit(IntegerLiteral n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = new ExpType(ExpType.Type.INT);
      return t;
   }

   /**
    * f0 -> "true"
    */
   public ExpType visit(TrueLiteral n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = new ExpType(ExpType.Type.BOOLEAN);
      return t;
   }

   /**
    * f0 -> "false"
    */
   public ExpType visit(FalseLiteral n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = new ExpType(ExpType.Type.BOOLEAN);
      return t;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public ExpType visit(Identifier n, Pair<String, Vector<Pair<String, ExpType>>> argu) {

      // Searches for the ID name in the local namespace
      String idname = n.f0.toString();
      

      for (Pair<String, ExpType> p: argu.y) {
          String posid = p.x;
          if (idname.equals(posid)) {
            return p.y;
          }
      }


      // Searches for the field in class & class hierarchy. If its not there, the 
      // getExtFieldType function will throw a type error because it won't be found. 
      ExpType t = ClassTypes.getExtFieldType(argu.x, idname);
      return t;
   }

   /**
    * f0 -> "this"
    */
   public ExpType visit(ThisExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      // If we are in the main class, then 'this' is a type error
      if (argu.x.equals(ClassTypes.mainClass)) {
        System.out.println("Invalid this");
        System.out.println("Type Error");
        System.exit(1);
      }

      // Returns the type of the class.
      ExpType t = new ExpType(ExpType.Type.ID, argu.x);
      return t;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public ExpType visit(ArrayAllocationExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = n.f3.accept(this, argu);
      if (t.getType() != ExpType.Type.INT) {
        System.out.println("Incorrect array expression");
        System.out.println("Type Error");
        System.exit(1);
      }

      // return intarr type
      ExpType newt = new ExpType(ExpType.Type.INTARR);
      return newt;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public ExpType visit(AllocationExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      String classname = n.f1.f0.toString();
      if (!ClassTypes.isAClass(classname)) {
        System.out.println("Problem with identifier in new");
        System.out.println("Type Error");
        System.exit(1);
      }
      ExpType t = new ExpType(ExpType.Type.ID, classname);

      return t;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public ExpType visit(NotExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = n.f1.accept(this, argu);
      if (t.getType() != ExpType.Type.BOOLEAN) {
        System.out.println("not error");
        System.out.println("Type Error");
        System.exit(1);
      }

      return t;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public ExpType visit(BracketExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      return n.f1.accept(this, argu);
   }

      /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public ExpType visit(ExpressionRest n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      return n.f1.accept(this, argu);
   }

}
