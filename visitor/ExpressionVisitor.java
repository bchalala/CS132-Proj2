//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import utility.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class ExpressionVisitor extends GJDepthFirst<ExpType,Pair<String, Vector<Pair<String, ExpType>>>> {

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public ExpType visit(Expression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      return n.f0.accept(this, argu);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(AndExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.BOOLEAN)
        return t1;
      
      // If the types aren't the same do this.
      System.out.println("Type Error");
      System.exit(1);

      
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(CompareExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.BOOLEAN)
        return t1;
      
      // If the types aren't the same do this.
      System.out.println("Type Error");
      System.exit(1);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(PlusExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.INT)
        return t1;
      
      // If the types aren't the same do this.
      System.out.println("Type Error");
      System.exit(1);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(MinusExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.INT)
        return t1;
      
      // If the types aren't the same do this.
      System.out.println("Type Error");
      System.exit(1);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public ExpType visit(TimesExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.isEqual(t2) && t1.getType() == ExpType.Type.INT)
        return t1;
      
      // If the types aren't the same do this.
      System.out.println("Type Error");
      System.exit(1);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public ExpType visit(ArrayLookup n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t1 = n.f0.accept(this, argu);
      ExpType t2 = n.f2.accept(this, argu);
      if (t1.getType() == ExpType.Type.INTARR && t2.getType == ExpType.Type.INT)
        return t2;
      
      // If the types aren't the same do this.
      System.out.println("Type Error");
      System.exit(1);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public ExpType visit(ArrayLength n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = n.f0.accept(this, argu);
      if (t.getType() == ExpType.Type.INTARR) {
        ExpType tnew = new ExpType(ExpType.Type.INT);
        return tnew;
      }
      
      System.out.println("Type Error");
      System.exit(1);   
    }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public ExpType visit(MessageSend n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      R _ret=null;
      ExpType t = n.f0.accept(this, argu);

      // Primary expression must result in a variable of a class.
      if (t.getType() != ExpType.Type.ID) {
        System.out.println("Type Error");
        System.exit(1);  
      }

      // Gets the name of the method
      String method = n.f2.f0.toString();

      // Retrieves method information (this type checks the method name)
      Vector<Pair<String, ExpType>> methodInfo = ClassTypes.getMethodInfo(t.getID(), method);

      // Use separate visitor to evaluate the method arguments.
      // IT WILL GO HERE!!!!!

      // Return the method type
      return methodInfo.elementAt(0).y;
   }


   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public ExpType visit(PrimaryExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = n.f0.accept(this, argu);
      return t;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public ExpType visit(IntegerLiteral n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = new ExpType(ExpType.Type.INT);
      return t;
   }

   /**
    * f0 -> "true"
    */
   public ExpType visit(TrueLiteral n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = new ExpType(ExpType.Type.BOOLEAN);
      return t;
   }

   /**
    * f0 -> "false"
    */
   public ExpType visit(FalseLiteral n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = new ExpType(ExpType.Type.BOOLEAN);
      return t;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public ExpType visit(Identifier n, Pair<String, Vector<Pair<String, ExpType>>> argu) {

      // Searches for the ID name in the local namespace
      String name = n.f0.toString();
      for (<Pair<String, ExpType>> p: argu.y) {
          if (p.x.equals(name))
            return p.y;
      }

      // Searches for the field in class & class hierarchy. If its not there, the 
      // getExtFieldType function will throw a type error because it won't be found.
      return ClassTypes.getExtFieldType(argu.x, name);
   }

   /**
    * f0 -> "this"
    */
   public ExpType visit(ThisExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      // If we are in the main class, then 'this' is a type error
      if (argu.x.equals(ClassTypes.mainClass)) {
        System.out.println("Type Error");
        System.exit(1);
      }

      // Returns the type of the class.
      ExpType t = new ExpType(ExpType.Type.ID, argu.x);
      return t;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public ExpType visit(ArrayAllocationExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = n.f3.accept(this, argu);
      if (t.getType() != ExpType.Type.INT) {
        System.out.println("Type Error");
        System.exit(1);
      }

      return t;

      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public ExpType visit(AllocationExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      String classname = n.f1.f0.toString();
      ClassTypes.isAClass(classname);
      ExpType t = new ExpType(ExpType.Type.ID, classname);

      return t;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public ExpType visit(NotExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      ExpType t = n.f1.accept(this, argu);
      if (t.getType() != ExpType.Type.BOOLEAN) {
        System.out.println("Type Error");
        System.exit(1);
      }

      return t;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public ExpType visit(BracketExpression n, Pair<String, Vector<Pair<String, ExpType>>> argu) {
      return n.f1.accept(this, argu);
   }

}
